# 优化加载顺序

在每次成功的网页加载中，一些关键组件和资源都会在适当的时间变得可用，从而为您提供流畅的加载体验。这可确保用户感受到应用程序的卓越性能。这种出色的用户体验通常也应该转化为通过核心网络生命力。

https://web.dev/articles/vitals?hl=zh-cn

用于衡量性能的关键指标（例如首次内容绘制、最大内容绘制、首次输入延迟等）直接取决于关键资源的加载顺序。例如，如果未加载诸如英雄图像之类的关键资源，则页面无法拥有其 LCP。本文讲的是资源的加载顺序和Web Vitals之间的关系。我们的目标是就如何优化加载顺序以获得更好的网络生命力提供明确的指导。

在我们建立理想的加载顺序之前，让我们首先尝试理解为什么获得正确的加载顺序如此困难。

## Web Vitals

“网页指标”是 Google 推出的一项计划，旨在针对对于提供出色的网页用户体验至关重要的质量信号提供统一指南。

多年来，Google 提供了许多工具来衡量和报告广告效果。有些开发者是这些工具的使用专家，也有些开发者发现难以跟上这些工具和指标的丰富程度。

网站所有者不必是效果专家，即可了解自己为用户提供的体验质量。“网页指标”计划旨在简化这一现状，帮助网站专注于最重要的指标，即核心网页指标。

## 核心网页指标

核心网页指标是网页指标的一部分，适用于所有网页，应由所有网站所有者进行衡量，并将在所有 Google 工具中提供。每个核心网页指标都代表用户体验的一个不同方面，可实际衡量，并且反映了以用户为中心的关键结果的实际体验。

构成 Core Web Vitals 的指标会随着时间的推移而演变。当前这组指标侧重于用户体验的三个方面（加载、互动和视觉稳定性），并包含以下指标（及其各自的阈值）：

- Largest Contentful Paint (LCP)：衡量加载性能。为了提供良好的用户体验，LCP 应在网页首次开始加载后的 2.5 秒内完成。
- Interaction to Next Paint (INP)：衡量互动性。为了提供良好的用户体验，网页的 INP 应不超过 200 毫秒。
- Cumulative Layout Shift (CLS)：衡量视觉稳定性。为了提供良好的用户体验，网页的 CLS 应保持为 0.1. 或更低。

2020 年，核心网页指标有三个指标：Largest Contentful Paint (LCP)、First Input Delay (FID) 和 Cumulative Layout Shift (CLS)。每个指标衡量用户体验的不同方面：

LCP 衡量感知到的加载速度，并在网页加载时间轴中标记页面主要内容可能已加载的时间点；

FID 用于衡量响应速度，并量化用户尝试首次与网页互动时的感受

而 CLS 则用于衡量视觉稳定性，并量化可见网页内容的意外布局偏移的数量。

每个 Core Web Vitals 指标都有关联的阈值，这些阈值将性能分为“良好”“需要改进”或“欠佳”：

此外，为了对网页或网站的整体性能进行分类，我们会使用该网页或网站的所有网页浏览量的第 75 百分位值。换言之，如果某个网站至少有 75% 的网页浏览量符合“良好”阈值，则对于该指标，该网站就会被归类为具有“良好”效果。相反，如果至少有 25% 的网页浏览量满足“较差”阈值，则该网站就会被归类为“效果不佳”。例如，第 75 个百分位 2 秒的 LCP 将归类为“良好”，而第 75 个百分位的 LCP 为 5 秒则归类为“欠佳”。

为了对网页或网站的整体性能进行分类，我们会使用该网页或网站的所有访问的第 75 百分位值。第 75 百分位是根据两个条件选择的。首先，百分位数应确保对网页或网站的大多数访问都达到了目标性能水平。其次，所选百分位处的值不应受到离群值的过度影响。

这两个目标有些不一致。为了满足第一个目标，通常较高的百分位数通常是更好的选择。但是，百分位数越高，生成的值受离群值影响的可能性也会增加。如果对网站的几次访问恰好使用的是不稳定的网络连接，从而导致 LCP 样本过大，我们不希望由这些离群样本决定网站分类。例如，如果我们使用高百分位（如第 95 百分位）评估一个有 100 次访问的网站的性能，那么第 95 个百分位值只需要 5 个离群样本即可受到这些离群值的影响。

鉴于这些目标有点矛盾，经过分析，我们得出第 75 百分位的合理平衡。通过使用第 75 个百分位，我们知道网站的大多数访问（3/4）都达到了目标性能水平或更高。此外，第 75 百分位值不太可能受离群值影响。回到我们的示例，对于访问量为 100 次的网站，其中 25 次访问需要报告第 75 个百分位处的较大离群样本，才能受离群值影响。虽然 100 个样本中有 25 个可能出现离群值，但与第 95 百分位的情况相比，这种可能性要低得多。

### 最大内容渲染时间

1 秒通常指用户在开始无法专注于某项任务之前需等待的时间。在进一步检查相关研究后，我们发现 1 秒是描述一系列值的近似值，范围从几百毫秒到几秒不等。

关于 1 秒阈值的两个常见引用来源是 Card etal 和 Miller。Card 引用了 Newell 的认知统一理论，定义了 1 秒的“立即响应”阈值。Newell 将立即响应解释为“必须在大约一秒（即大约从大约 0.3 秒到大约 3 秒）内对某些刺激作出的响应”。继此，Newell 在关于“认知的实时限制”的讨论中指出，“与环境的互动会引起认知，大约几秒钟的时间，范围约为 0.5 到 2-3 秒。Miller 是另一个经常提到的关于 1 秒阈值的问题来源，他指出：“如果响应延迟超过 2 秒，人类可以并且将通过机器通信执行的任务将严重改变其性质，有些任务可能会延长 1 秒左右。”

Miller 和 Card 的研究描述了用户在失去焦点之前将等待的时间，范围大约为 0.3 到 3 秒，表明我们的 LCP“良好”阈值应在此范围内。此外，由于现有的 First Contentful Paint 的“良好”阈值为 1 秒，并且 Largest Contentful Paint 通常发生在 First Contentful Paint 之后，因此我们会进一步限制候选 LCP 阈值的范围，从 1 秒到 3 秒。为了在此范围内选择最符合我们标准的阈值，我们会在下面查看这些候选阈值的实现性。

使用 CrUX 中的数据，我们可以确定 Web 上符合候选 LCP“良好”阈值的源所占的百分比。

2.5 秒是一个合理的“良好”阈值，而 4 秒是一个合理的“欠佳”阈值，适用于 Largest Contentful Paint。

### First Input Delay

研究得出的结论是，长达 100 毫秒的视觉反馈延迟可被认为是由相关来源（例如用户输入）导致的。这表明，100 毫秒 First Input Delay 的“良好”阈值作为一个最低标准，可能是合适的：如果处理输入的延迟时间超过 100 毫秒，其他处理和渲染步骤没有机会及时完成。

时间延迟：不超过 0.1 秒”，之后“按下按键与视觉反馈之间的延迟时间不应超过 0.1 到 0.2 秒”。

### 累积布局偏移

Cumulative Layout Shift (CLS) 是一项新指标，用于衡量页面的可见内容偏移的程度。鉴于 CLS 是一项新功能，我们不知道能够直接确定该指标阈值的研究。因此，为了确定符合用户预期的阈值，我们评估了具有不同布局偏移的实际网页，以确定在浏览网页内容时造成严重中断之前，用户认为可接受的最大偏移量。在我们的内部测试中，我们发现，从 0.15 及以上范围内的变化程度始终被认为具有干扰性，而 0.1 及以下的变动幅度则很明显，但不会过度干扰。因此，虽然零布局偏移是理想情况，但我们推断值为不高于 0.1 的候选 CLS 阈值是“良好”的 CLS 阈值。

## 核心网页指标概览

### 什么是 LCP（Largest Contentful Paint）

LCP 会报告视口中可见的最大图片、文本块或视频的呈现时间（相对于用户首次导航到相应网页的时间）。

**会考虑哪些元素**
- `<img>` 元素（第一帧呈现时间用于动画内容，例如 GIF 或动画 PNG）
- `<svg>` 元素内的 `<image>` 元素
- `<video>` 元素（使用海报图片加载时间或视频的第一帧呈现时间，以两者中较早达到者为准）
- 此元素包含使用 url() 函数加载的背景图片（与 CSS 渐变相反）
- 包含文本节点或其他内嵌级文本元素子级的块级元素。

LCP 衡量不仅仅考虑部分元素，还会使用启发法来排除用户可能会视为“非内容”的某些元素。对于基于 Chromium 的浏览器，包括：
- 不透明度为 0 且对用户不可见的元素
- 覆盖整个视口的元素，此类元素可能会被视为背景（而非内容）
- 占位符图片或其他具有低熵的图片，可能无法反映网页的实际内容

这些“内容”启发式算法可能与 First Contentful Paint (FCP) 使用的算法不同，FCP 可能会考虑其中一些元素，例如占位图片或完整视口图片，即使它们不符合 LCP 候选条件。尽管两者都使用“contentful”但这些指标的目的有所不同。FCP 会衡量何时将任何内容绘制到屏幕上，以及 LCP 何时绘制到主内容，以便提高 LCP 的选择性。

**元素大小是如何确定的？**

针对 LCP 报告的元素的尺寸通常是用户在视口内可见的尺寸。如果元素延伸到视口之外，或者任何元素被截断或具有不可见的“溢出”，则这些部分不会计入元素的尺寸。

对于已根据固有尺寸调整大小的图片元素，报告的尺寸是可见尺寸或固有尺寸（以较小者为准）。

对于文本元素，LCP 仅考虑可包含所有文本节点的最小矩形。

对于所有元素，LCP 不会考虑使用 CSS 应用的外边距、内边距或边框。

**何时报告 LCP？**

网页通常会分阶段加载，因此，网页上最大的元素可能会发生变化。

为了应对这种可能的改变，浏览器会在绘制完第一帧后，立即分派类型为 largest-contentful-paint 的 PerformanceEntry，用于识别最大的内容元素。但是，在渲染后续帧后，只要最大的内容元素发生变化，它就会分派另一个 PerformanceEntry。

例如，在包含文字和主打图片的网页上，浏览器最初可能只会呈现文字，此时浏览器会分派 largest-contentful-paint 条目，其 element 属性可能会引用 `<p>` 或 `<h1>`。稍后，当主打图片完成加载后，系统会分派第二个 largest-contentful-paint 条目，并且其 element 属性将引用 `<img>`。

元素只有在已呈现且对用户可见后，才会被视为最大的内容元素。尚未加载的图片不会被视为“已呈现”。在字体阻止期内，使用网页字体的文本节点也不例外。在这种情况下，较小的元素可能会被报告为最大的内容元素，但当较大的元素完成渲染后，系统会立即创建另一个 PerformanceEntry。

除了延迟加载图片和字体之外，当有新内容可用时，页面可能还会向 DOM 添加新元素。如果其中任何新元素大于之前的最大内容元素，系统还会报告一个新的 PerformanceEntry。

如果从视口甚至 DOM 中移除最大的内容元素，除非呈现更大的元素，否则它仍然是最大的内容元素。

只要用户与网页互动（通过点按、滚动或按键），浏览器就会立即停止报告新条目，因为用户互动通常会改变对用户可见的内容（滚动时更是如此）。

为便于分析，您应只将最近分派的 PerformanceEntry 报告给分析服务。

**在 JavaScript 中衡量 LCP**

如需在 JavaScript 中衡量 LCP，您可以使用 Largest Contentful Paint API。以下示例展示了如何创建 PerformanceObserver 来监听 largest-contentful-paint 条目并将其记录到控制台中。

``` JavaScript
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});
```

指标与 API 之间的区别

- API 将为后台标签页中加载的网页分派 largest-contentful-paint 条目，但在计算 LCP 时应忽略这些网页。
- 在网页转到后台运行后，API 会继续分派 largest-contentful-paint 条目，但在计算 LCP 时应忽略这些条目（只有在网页始终位于前台时，才能考虑这些元素）。
- 当网页从往返缓存中恢复时，API 不会报告 largest-contentful-paint 条目，但在这种情况下，应对 LCP 进行衡量，因为用户的体验是将它们视为不同的网页访问。
- API 不会考虑 iframe 中的元素，但该指标会考虑到它们是网页用户体验的一部分。在 iframe 内包含 LCP 的网页（例如嵌入式视频中的海报图片）中，系统会显示 CrUX 与 RUM 之间的差异。若要正确衡量 LCP，您应考虑这些指标。子帧可以使用该 API 将其 largest-contentful-paint 条目报告给父帧以进行聚合。
- API 从导航开始开始测量 LCP，但对于预渲染的网页，LCP 应从 activationStart 开始测量，因为这与用户所体验到的 LCP 时间相对应。

### Interaction to Next Paint (INP)

良好的响应速度意味着网页可以快速响应互动。当网页响应互动时，浏览器会在其绘制的下一帧中提供视觉反馈。例如，视觉反馈会告诉您是否确实添加了您添加到在线购物车中的商品、移动导航菜单是否打开、服务器是否正在对登录表单的内容进行身份验证等。

有些互动的用时自然要长于其他互动，但对于特别复杂的互动，必须快速显示一些初始视觉反馈，让用户知道正在发生某件事。浏览器要绘制的下一帧是最早执行此操作的机会。

因此，INP 的目的不是衡量互动的所有最终影响（例如来自其他异步操作的网络提取和界面更新），而是衡量下一次绘制被阻止的时间。延迟视觉反馈可能会让用户觉得页面响应速度不够快，因此开发了 INP，旨在帮助开发者衡量这部分用户体验。

**什么是 INP？**

INP 是一项指标，通过观察用户在访问网页的整个生命周期内发生的所有点击、点按和键盘互动的延迟时间，评估网页对用户互动的总体响应情况。最终 INP 值是观测到的最长互动时间，离群值会被忽略。

**INP 的计算方式详情**

INP 的计算方法是观察用户与网页进行的所有互动。对于大多数网站，延迟时间最长的互动会报告为 INP。

不过，对于具有大量互动的网页，随机中断可能会导致在响应迅速的网页上进行互动。网页上发生的互动越多，发生这种情况的可能性就越大。

为了更好地衡量互动次数较多的网页的实际响应速度，我们会忽略每 50 次互动中一次最高的互动。绝大多数网页体验都不到 50 次互动，因此最差的互动最常被报告。然后，系统会照常报告所有网页浏览量的第 75 个百分位，从而进一步移除离群值，从而给出绝大多数用户体验或更好的值。

互动是指在同一逻辑用户手势期间触发的一组事件处理脚本。例如，“点按”触摸屏设备上的互动包括多个事件，例如 pointerup、pointerdown 和 click。互动可由 JavaScript、CSS、内置浏览器控件（例如表单元素）或以上各项的组合驱动。

互动的延迟时间包括从用户开始互动到浏览器绘制下一帧时，推动互动的一组事件处理脚本的最长单个时长。

**互动中包含哪些内容？**

互动的主要驱动因素通常是 JavaScript，不过浏览器确实通过未由 JavaScript 提供支持的控件（例如复选框、单选按钮以及由 CSS 提供支持的控件）提供互动功能。

就 INP 而言，系统仅观察到以下互动类型：
- 使用鼠标点击。
- 点按带有触摸屏的设备。
- 按实体键盘或屏幕键盘上的某个键。

### Cumulative Layout Shift (CLS)

当以异步方式加载资源，或将 DOM 元素动态添加到网页中的现有内容之前时，通常会发生网页内容意外移动。导致布局偏移的原因可能包括尺寸未知的图片或视频、呈现的字体大于或小于其初始后备尺寸，或者是会自行动态调整大小的第三方广告或微件。

网站在开发中的运行方式与其用户体验之间的差异会让问题更严重。例如：

在开发阶段和生产环境中，个性化内容或第三方内容的行为往往有所不同。

测试图片通常已经在开发者的浏览器缓存中，但最终用户需要更长的时间来加载它们。

在本地运行的 API 调用速度通常非常快，以至于开发过程中察觉不到的延迟，可能会在生产环境中显著增加。

Cumulative Layout Shift (CLS) 指标可测量真实用户出现此问题的频率，从而帮助您解决此问题。

CLS 衡量的是页面整个生命周期内发生的每次意外布局偏移的最大布局偏移分数爆发。

每当可见元素在渲染帧中发生位置改变时，就会发生布局偏移。（本指南的后面部分将详细介绍如何计算各个布局偏移分数。）

突发布局偏移称为会话窗口，是指一次或多次单独的布局偏移快速连续发生，且每次偏移之间间隔不到 1 秒，且整个窗口时长最多为 5 秒。

**布局偏移详情**

布局偏移由 Layout Instability API 定义，该 API 会在视口内可见的元素在两帧之间更改起始位置（例如，在默认写入模式下的顶部和左侧位置）时报告 layout-shift 条目。此类元素被视为不稳定的元素。

请注意，仅当现有元素更改其起始位置时，才会发生布局偏移。如果向 DOM 添加了新元素或现有元素更改了大小，则不计为布局偏移，只要更改不会导致其他可见元素更改其起始位置即可。

动画和过渡
如果制作得当，动画和过渡是在不让用户感到惊讶的情况下更新网页内容的好方法。在网页上出现突然和意外的内容时，往往会导致糟糕的用户体验。但是，从一个位置自然而然地逐步移动的内容通常可以帮助用户更好地理解发生的情况，并引导他们在状态变化之间进行切换。

请务必遵循 prefers-reduced-motion 浏览器设置，因为动画可能会导致某些网站访问者的不良反应或注意力问题。

借助 CSS transform 属性，您可以为元素添加动画效果，而不触发布局偏移：

请使用 transform: scale()，而不要更改 height 和 width 属性。

如需移动元素，请避免更改 top、right、bottom 或 left 属性，而改为使用 transform: translate()。


## 为什么最佳负载难以实现？

我们有独特的机会对许多合作伙伴的网站进行性能分析。我们发现了多个类似的问题，这些问题困扰着不同合作伙伴网站上页面的高效加载。

开发人员的期望与浏览器如何对页面上的资源进行优先级排序之间通常存在重大差距。这通常会导致性能分数次优。我们进一步分析以找出造成这种差距的原因，以下几点总结了我们分析的实质。

### Sub-optimal sequencing 次优测序

Web Vitals优化不仅需要充分了解每个指标的含义，还需要了解它们发生的顺序以及它们与不同关键资源的关系。 FCP 发生在 LCP 之前，LCP 发生在 FID 之前。因此，实现 FCP 所需的资源应优先于 LCP 所需的资源，然后是 FID 所需的资源。

资源通常没有按照正确的顺序进行排序和管道化。这可能是因为开发人员没有意识到指标对资源负载的依赖性。因此，有时相关资源无法在正确的时间触发相应的指标。

### Network/CPU Utilization 网络/CPU利用率

资源也没有适当地管道化以确保 CPU 和网络的充分利用。当进程受到网络限制时，这会导致 CPU 上出现“死区时间”，反之亦然。

一个很好的例子是可以同时或顺序下载的脚本。由于并发下载期间带宽被划分，因此对于顺序下载和并发下载，下载所有脚本的总时间是相同的。如果同时下载脚本，则下载过程中 CPU 利用率不足。但是，如果您按顺序下载脚本，则 CPU 可以在下载第一个脚本后立即开始处理。这会带来更好的 CPU 和网络利用率。

### Third-Party (3P) Products

通常需要 3P 库向网站添加常见特性和功能。第三方包括广告、分析、社交小部件、实时聊天和其他为网站提供支持的嵌入内容。第三方库带有自己的 JavaScript、图像、字体等

3P 产品通常没有动力去优化和支持消费者网站的加载性能。它们可能会产生沉重的 JavaScript 执行成本，从而延迟交互性，或妨碍其他关键资源的下载。

包含 3P 产品的开发人员可能更倾向于关注其在功能方面增加的价值，而不是性能影响。因此，有时会随意添加 3P 资源，而没有充分考虑如何适应整体加载顺序。这使得它们难以控制和安排。

### Platform Quirks 平台怪癖

浏览器在如何确定请求的优先级和实现提示方面可能有所不同。如果您对平台及其怪癖有深入的了解，优化就会更容易。特定浏览器的特定行为使得难以一致地实现所需的加载顺序。

一个例子是 chromium 平台上的预加载错误。 Preload ( `<link rel=preload>` )指令可用于告诉浏览器尽快下载关键资源。仅当您确定资源将在当前页面上使用时才应使用它。 Chromium 中的错误导致其行为使得通过`<link rel=preload>`发出的请求始终在预加载扫描器看到的其他请求之前启动，即使这些请求具有更高的优先级。诸如此类的问题阻碍了优化计划。

### HTTP2 Prioritization HTTP2 优先级

协议本身没有提供很多选项或旋钮来调整资源的顺序和优先级。即使可以提供更好的优先级原语， HTTP2 优先级也存在潜在问题，导致优化排序变得困难。主要是，我们无法预测服务器或 CDN 将以什么顺序优先考虑单个资源的请求。一些 CDN 会重新确定请求的优先级，而其他 CDN 则实施部分优先级、有缺陷的优先​​级或无优先级。

### Resource level optimization 资源水平优化

有效的排序需要以最佳方式提供正在排序的资源，以便它们能够快速加载。关键的 CSS 应该内联，图像的大小应该正确，JS 应该进行代码分割并增量交付。

该框架本身缺乏允许代码分割和增量服务 JS 和数据的结构。用户必须依赖以下之一来分割大块的 1P JS

- 现代反应（悬念/并发模式/数据获取）-这仍然仅可用于实验
    https://17.reactjs.org/docs/concurrent-mode-reference.html
- 使用动态导入进行延迟加载 - 这并不直观，开发人员需要手动识别分割代码的边界。

在代码分割时，由于粒度与性能的权衡，开发人员需要实现正确的块粒度。

更高的粒度是可取的，因为它
- 最大限度地减少单个路由和后续用户交互所需的 JS
- 允许缓存常见依赖项。这确保了库中的更改不需要重新获取整个包

同时，代码分割时粒度太大可能会很糟糕，因为太多的小块会降低单个块的压缩率并影响浏览器性能。

资源优化还需要消除死代码或未使用的代码。不必要的或过时的 JS 可能经常被发送到现代浏览器，这会对性能产生负面影响。对于现代浏览器来说，不需要将 JS 转译为 ES5 并与 polyfill 捆绑在一起。库和 npm 包通常不以 ES 模块格式发布。这使得捆绑商很难进行树摇动和优化

您可能已经注意到，这些问题并不限于一组特定的资源或平台。要解决这些问题，需要了解整个技术堆栈以及如何合并不同的资源以实现最佳指标。在我们定义整体优化策略之前，让我们看看个别资源需求如何违背我们的目的。

## 有关资源的更多信息 - 关系、约束和优先级

在上一节中，我们给出了一些示例，说明如何触发 FCP 或 LCP 等特定事件需要某些资源。在讨论使用它们的方法之前，让我们首先尝试理解所有这些依赖关系。以下是在定义理想序列之前需要考虑的建议、约束和陷阱的资源明智列表。

### Critical CSS 关键CSS

关键 CSS是指 FCP 所需的最低 CSS。最好将此类 CSS 内联到 HTML 中，而不是从另一个 CSS 文件导入。在任何给定时间只应下载路由所需的 CSS，并且应相应地拆分所有关键 CSS。

如果无法内联，则应预加载关键 CSS，并从与文档相同的源提供服务。避免从多个域提供关键 CSS 或直接使用第三方关键 CSS（例如 Google Fonts）。您自己的服务器可以充当第 3 方关键 CSS 的代理。

获取 CSS 的延迟或获取 CSS 的顺序不正确可能会影响 FCP 和 LCP。为了避免这种情况，非内联 CSS 应优先排序并排在网络上的 1P JS 和 ATF 图像之上。

过多的内联 CSS 可能会导致 HTML 膨胀以及主线程上的样式解析时间过长。这可能会伤害 FCP。因此，确定关键内容和代码分割至关重要。

内联 CSS 无法缓存。解决此问题的一种方法是对可缓存的 CSS 进行重复请求。但请注意，这可能会导致多个整页布局，从而影响 FID。

### Fonts 字体

与关键 CSS 一样，关键字体的 CSS 也应该内联。如果无法内联，则应使用指定的预连接来加载脚本。获取字体（例如，谷歌字体或来自不同域的字体）的延迟可能会影响 FCP。预连接告诉浏览器提前建立与这些资源的连接。

内联字体会使 HTML 显着膨胀并延迟启动其他关键资源获取。字体回退可用于解锁 FCP 并使文本可用。但是，使用字体回退可能会因跳跃字体而影响CLS 。由于当真实字体到达时，主线程上可能存在较大的样式和布局任务，因此它还会影响 FID。

### Above the Fold (ATF) Images 首屏 (ATF) 图像

这是指用户在页面加载时最初可见的图像，因为它们位于视口内。 ATF 图像的一个特例是页面的英雄图像。所有 ATF 图像都应调整大小。未调整大小的图像会损害 CLS 指标，因为完全渲染时会发生布局变化。 ATF 图像的占位符应由服务器呈现。

延迟的英雄图像或空白占位符将导致 LCP 延迟。此外，如果占位符大小与实际英雄图像的固有大小不匹配并且图像在替换时未覆盖，LCP 将重新触发。理想情况下，ATF 图像不应对 FCP 产生影响，但实际上，图像可能会引发 FCP。

### Below the Fold (BTF) Images 非首屏 (BTF) 图片

这些图像在页面加载时不会立即对用户可见。因此，它们是延迟加载的理想选择。这确保它们不会与页面上所需的 1P JS 或重要的 3P 发生冲突。如果 BTF 图像在 1P JS 或重要的 3P 资源之前加载，FID 就会延迟。

### 1P JavaScript

1P JS 影响应用程序的交互准备情况。它可能会在图像和 3P JS 后面的网络上以及 3P JS 后面的主线程上出现延迟。因此，它应该在网络上的 ATF 图像之前开始加载，并在主线程上的 3P JS 之前执行。 1P JS 不会阻止服务器端渲染的页面中的 FCP 和 LCP。

### 3P JavaScript

HTML 头中的 3P 同步脚本可能会阻止 CSS 和字体解析，从而阻止 FCP。 head 中的同步脚本也会阻止 HTML body 解析。主线程上的 3P 脚本执行可以延迟 1P 脚本执行并推出 Hydration 和 FID。因此，加载 3P 脚本需要更好的控制。

无论技术堆栈和浏览器如何，这些建议和限制通常都适用。请注意，建议也可能成为约束。例如，内联字体和 CSS 很棒，但太多会导致臃肿。诀窍是在“太少太晚”和“太多太早”之间找到平衡。

1. CSS 和字体以最高优先级加载。这应该可以帮助我们确定关键 CSS 和字体的优先级。
2. 根据脚本在文档中的位置以及它们是异步、延迟还是阻塞，脚本会获得不同的优先级。在第一个图像（或文档中较早的图像）之前请求的阻止脚本比在获取第一个图像之后请求的阻止脚本具有更高的优先级。异步/延迟/注入脚本，无论它们位于文档中的哪个位置，都具有最低优先级。因此，我们可以通过使用async 和 defer的适当属性来优先考虑不同的脚本。
3. 可见且位于视口中的图像的优先级（净值：中）高于不在视口中的图像（净值：最低）。这有助于我们优先考虑 ATF 图像而不是 BTF 图像。

## 理想的加载顺序是什么

有了这个背景，我们现在可以提出一个加载顺序，该顺序应该优化 1P 和 3P 资源的加载。建议的序列使用Next.js服务器端渲染 (SSR) 作为优化参考。

根据我们的经验，以下是我们在优化之前观察到的 Next.js SSR 应用程序的典型加载顺序。

CSS 在 JS 之前预加载，但未内联JavaScript

1P JS 已预加载

3P JS 不受管理，仍然可以在文档中的任何位置阻塞渲染。

Fonts 字体

字体既不是内联的，也不使用预连接

字体通过外部样式表加载，这会延迟加载

字体可能会或可能不会显示阻塞。

Images 图片

英雄图像没有优先顺序

Both ATF and BTF images are not optimized

ATF 和 BTF 图像均未优化

### 没有 3P 的建议序列

1. 我们建议尽可能避免预加载，因为它会强制对每个前面的资源进行手动预加载，并且还会导致手动管理排序。尤其应避免对字体进行预加载，因为检测关键字体很困难。
2. Font-CSS 最好是内联的。应使用预连接获取来自其他来源的字体。
3. 建议对来自其他来源的所有资源进行预连接。这将确保提前建立连接来下载这些资源。
4. 应在用户交互开始 (FID) 之前获取非关键 CSS。这将避免由于后续渲染此类 CSS 导致的样式问题。
5. 在网络上先获取第一方 JS，再获取 ATF 图片。下载和解析 JS 需要一些时间。
6. 在解析 1P JS 的同时，主线程上的 HTML 解析和 ATF 图像的下载可以并行继续。

为了实现所需的顺序，我们建议对 Next 使用 ScriptLoader 组件。该组件旨在“优化关键渲染路径并确保外部脚本不会成为最佳页面加载的瓶颈。”与我们的讨论最相关的功能是加载优先级。这使我们能够在不同的里程碑安排脚本以支持不同的用例。以下是可用的加载优先级值

After-Interactive: Loads the specific 3P script after the next hydration. This can be used to load Tag-managers, Ads, or Analytics scripts that we want to execute as early as possible but after 1P scripts.
After-Interactive ：下次水合后加载特定的3P脚本。这可用于加载我们希望在 1P 脚本之后尽早执行的标签管理器、广告或分析脚本。

Before-Interactive: Loads the specific 3P script before hydration. It can be used in cases where we want the 3P script to execute before the 1P script. Eg., polyfill.io, bot detection, security and authentication, user consent management (GDPR), etc.
Before-Interactive ：在水合之前加载特定的 3P 脚本。它可以用于我们希望 3P 脚本在 1P 脚本之前执行的情况。例如，polyfill.io、机器人检测、安全和身份验证、用户同意管理 (GDPR) 等。

Lazy-Onload: Prioritize all other resources over the specified 3P script and lazy load the script. It can be used for CRM components like Google Feedback or Social Network specific scripts like those used for share buttons, comments, etc.
Lazy-Onload ：将所有其他资源优先于指定的 3P 脚本并延迟加载脚本。它可用于 CRM 组件，例如 Google 反馈或社交网络特定脚本，例如用于共享按钮、评论等的脚本。

Thus, preconnect, script attributes and ScriptLoader for Next.js together can help us get the desired sequence for all our scripts.
因此，预连接、脚本属性和 Next.js 的 ScriptLoader 一起可以帮助我们获得所有脚本所需的序列。