import Example from './example'
import Example2 from './example2'

# 坐标系和向量  

## 坐标系与坐标映射  

- HTML 采用的是窗口坐标系，以参考对象的元素盒子左上角为坐标原点，x 轴向右，y 轴向下，坐标值对应像素值。  

- SVG 采用的是视区盒子（viewBox）坐标系。这个坐标系在默认情况下，是以 svg 根元素左上角为坐标原点，x 轴向右，y 轴向下，svg 根元素右下角坐标为它的像素宽高值。如果我们设置了 viewBox 属性，那么 svg 根元素左上角为 viewBox 的前两个值，右下角为 viewBox 的后两个值。  

- Canvas 默认以画布左上角为坐标原点，右下角坐标值为 Canvas 的画布宽高值。  

- WebGL 的坐标系比较特殊，是一个三维坐标系。它默认以画布正中间为坐标原点，x 轴朝右，y 轴朝上，z 轴朝外，x 轴、y 轴在画布中范围是 -1 到 1。  

**以 Canvas 为例，来看看用 transform API 怎样进行坐标转换**  

### 如何用 Canvas 实现坐标系转换？  

宽 512 * 高 256 的一个 Canvas 画布上实现如下的视觉效果:  

<Example />

计算的过程：
1. 因为 Canvas 坐标系默认的原点是左上角，底边的 y 坐标是 256，而山的高度是 100，所以山顶点的 y 坐标是 256 - 100 = 156。而因为太阳的高度是 150，所以太阳圆心的 y 坐标是 256 - 150 = 106。
2. 然后，因为 x 轴中点的坐标是 512 / 2 = 256，所以两座山顶点的 x 坐标分别是 256 - 80 和 256 + 80，也就是 176 和 336。又因为山是等腰三角形，它的底边是 200，所以两座山底边的 x 坐标计算出来，分别是 76、276、236、436（176 - 100 =76、176 + 100=276、336 - 100=236、 336 + 100=436）。

如果每次绘制都要花费时间在坐标换算上，这会非常不方便。所以，为了解决这个问题，我们可以采用坐标系变换来代替坐标换算。  

首先，我们通过 translate 变换将 Canvas 画布的坐标原点，从左上角 (0, 0) 点移动至 (256, 256) 位置，即画布的底边上的中点位置。接着，以移动了原点后新的坐标为参照，通过 scale(1, -1) 将 y 轴向下的部分，即 y>0 的部分沿 x 轴翻转 180 度，这样坐标系就变成以画布底边中点为原点，x 轴向右，y 轴向上的坐标系了。  

两个山顶的坐标就是 (-80, 100) 和 (80, 100)，山脚的坐标就是 (-180, 0)、(20, 0)、(-20, 0)、(180, 0)，太阳的中心点的坐标就是 (0, 150)。那么更改后的代码如下所示。  

<Example2 />

``` javascript
  useEffect(() => {
    if (canvasRef?.current) {
      const rc = rough.canvas(canvasRef?.current);
      // @ts-ignore
      const ctx = canvasRef?.current?.getContext('2d');
      ctx.save();
      ctx.translate(256, 256);
      ctx.scale(1, -1);

      const hillOpts = { roughness: 2.8, strokeWidth: 2, fill: 'blue' };

      rc.path('M-180 0L-80 100L20 0', hillOpts);
      rc.path('M-20 0L80 100L180 0', hillOpts);

      rc.circle(0, 150, 105, {
        stroke: 'red',
        strokeWidth: 4,
        fill: 'rgba(255,255, 0, 0.4)',
        fillStyle: 'solid',
      });

      ctx.restore();
    }
  }, []);
```

我们在原始坐标下通过计算顶点来绘制图形，计算量会非常大  

那采用坐标变换的方式就是一个很好的优化思路，它能够简化计算量，这不仅让代码更容易理解，也可以节省 CPU 运算的时间。  

### 如何用向量来描述点和线段？

那在直角坐标系下，我们是怎么表示点和线段的呢？我们一般是用向量来表示一个点或者一个线段。  

假设，现在这个平面直角坐标系上有一个向量 v。向量 v 有两个含义：一是可以表示该坐标系下位于 (x, y) 处的一个点；二是可以表示从原点 (0,0) 到坐标 (x,y) 的一根线段。  

**向量的数学知识**  

1. 首先，向量和标量一样可以进行数学运算。举个例子，现在有两个向量，v1和 v2，如果让它们相加，其结果相当于将 v1向量的终点（x1, y1），沿着 v2向量的方向移动一段距离，这段距离等于 v2向量的长度。这样，我们就可以在平面上得到一个新的点（x1 + x2, y1 + y2），一条新的线段[(0, 0), (x1 + x2, y1 + y2)]，以及一段折线：[(0, 0), (x1, y1) , (x1 + x2, y1 + y2)]。  

2. 其次，一个向量包含有长度和方向信息。它的长度可以用向量的 x、y 的平方和的平方根来表示，如果用 JavaScript 来计算，就是：  

``` javascript
v.length = function(){return Math.hypot(this.x, this.y)};
```  

角度:  

``` javascript
v.dir = function() { return Math.atan2(this.y, this.x);}
```  

### 向量运算的意义  

可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础。  

**向量加法在绘制和处理线段时具有重要的意义**  

- 平移线段：通过向量加法可以实现线段的平移，即将线段从一个位置移动到另一个位置。  
- 计算线段的中点：向量加法可以用于计算线段的中点，这在几何计算和绘图中非常有用。  
- 延伸线段：通过向量加法可以延伸线段的长度，即在原有线段基础上添加新的长度。  

**标量乘法**  
定义：将一个向量 𝑎 a 和一个标量 𝑘 k 相乘，得到一个新的向量 𝑏 b，其方向与 𝑎 a 相同或相反，长度为 𝑎 a 的  𝑘 k 倍。  

意义：  
- 缩放：标量乘法用于缩放向量的长度

**点积（内积）**  

定义：两个向量 𝑎 a 和 𝑏 b 的点积是一个标量，  

定义为： 𝑎 ⋅ 𝑏 = 𝑎 1 𝑏 1 + 𝑎 2 𝑏 2 + 𝑎 3 𝑏 3 = ∣ 𝑎 ∣ ∣ 𝑏 ∣ cos ⁡ 𝜃  

其中 𝜃 θ 是 𝑎 a 和 𝑏 b 之间的夹角。  

意义：  
- 投影：点积用于计算一个向量在另一个向量方向上的投影  
- 正交性判断：如果 𝑎 ⋅ 𝑏 = 0 a⋅b=0，则向量 𝑎 a 和 𝑏 b 互相垂直。  

**叉积（外积）**  

定义：两个三维向量 𝑎 a 和 𝑏 b 的叉积是一个新的向量 𝑐 c，其方向垂直于 𝑎 a 和 𝑏 b 所在的平面，且长度为：  

𝑎 × 𝑏 = ∣ 𝑎 ∣ ∣ 𝑏 ∣ sin ⁡ 𝜃 𝑛 a×b=∣a∣∣b∣sinθn   

其中 𝜃 θ 是 𝑎 a 和 𝑏 b 之间的夹角， 𝑛 n 是垂直于 𝑎 a 和 𝑏 b 的单位向量，其方向由右手定则决定。  

意义：  
- 面积计算 叉积的长度等于由 𝑎 a 和 𝑏 b 组成的平行四边形的面积。  
- 方向判断：叉积的结果向量方向可以用于确定两个向量的相对方向，这在计算机图形学和物理学中非常有用。  

**归一化**  

向量归一化（Vector Normalization）是将一个向量的长度（或模）调整为1，同时保留其方向。归一化后的向量称为单位向量（Unit Vector）。  

向量归一化的目的和意义  
- 统一尺度：将不同长度的向量转换为相同的长度（即1），便于比较和计算。
- 标准化处理：在许多算法中，使用单位向量可以简化计算，并使算法更加稳定和有效。
- 方向保持：归一化不会改变向量的方向，仅调整其长度。

# 如何用向量描述曲线？