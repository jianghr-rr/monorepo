# 优化加载顺序

在每次成功的网页加载中，一些关键组件和资源都会在适当的时间变得可用，从而为您提供流畅的加载体验。这可确保用户感受到应用程序的卓越性能。这种出色的用户体验通常也应该转化为通过核心网络生命力。

https://web.dev/articles/vitals?hl=zh-cn

用于衡量性能的关键指标（例如首次内容绘制、最大内容绘制、首次输入延迟等）直接取决于关键资源的加载顺序。例如，如果未加载诸如英雄图像之类的关键资源，则页面无法拥有其 LCP。本文讲的是资源的加载顺序和Web Vitals之间的关系。我们的目标是就如何优化加载顺序以获得更好的网络生命力提供明确的指导。

在我们建立理想的加载顺序之前，让我们首先尝试理解为什么获得正确的加载顺序如此困难。

## 为什么最佳负载难以实现？

我们有独特的机会对许多合作伙伴的网站进行性能分析。我们发现了多个类似的问题，这些问题困扰着不同合作伙伴网站上页面的高效加载。

开发人员的期望与浏览器如何对页面上的资源进行优先级排序之间通常存在重大差距。这通常会导致性能分数次优。我们进一步分析以找出造成这种差距的原因，以下几点总结了我们分析的实质。

### Sub-optimal sequencing 次优测序

Web Vitals优化不仅需要充分了解每个指标的含义，还需要了解它们发生的顺序以及它们与不同关键资源的关系。 FCP 发生在 LCP 之前，LCP 发生在 FID 之前。因此，实现 FCP 所需的资源应优先于 LCP 所需的资源，然后是 FID 所需的资源。

资源通常没有按照正确的顺序进行排序和管道化。这可能是因为开发人员没有意识到指标对资源负载的依赖性。因此，有时相关资源无法在正确的时间触发相应的指标。

### Network/CPU Utilization 网络/CPU利用率

资源也没有适当地管道化以确保 CPU 和网络的充分利用。当进程受到网络限制时，这会导致 CPU 上出现“死区时间”，反之亦然。

一个很好的例子是可以同时或顺序下载的脚本。由于并发下载期间带宽被划分，因此对于顺序下载和并发下载，下载所有脚本的总时间是相同的。如果同时下载脚本，则下载过程中 CPU 利用率不足。但是，如果您按顺序下载脚本，则 CPU 可以在下载第一个脚本后立即开始处理。这会带来更好的 CPU 和网络利用率。

### Third-Party (3P) Products

通常需要 3P 库向网站添加常见特性和功能。第三方包括广告、分析、社交小部件、实时聊天和其他为网站提供支持的嵌入内容。第三方库带有自己的 JavaScript、图像、字体等

3P 产品通常没有动力去优化和支持消费者网站的加载性能。它们可能会产生沉重的 JavaScript 执行成本，从而延迟交互性，或妨碍其他关键资源的下载。

包含 3P 产品的开发人员可能更倾向于关注其在功能方面增加的价值，而不是性能影响。因此，有时会随意添加 3P 资源，而没有充分考虑如何适应整体加载顺序。这使得它们难以控制和安排。

### Platform Quirks 平台怪癖

浏览器在如何确定请求的优先级和实现提示方面可能有所不同。如果您对平台及其怪癖有深入的了解，优化就会更容易。特定浏览器的特定行为使得难以一致地实现所需的加载顺序。

一个例子是 chromium 平台上的预加载错误。 Preload ( `<link rel=preload>` )指令可用于告诉浏览器尽快下载关键资源。仅当您确定资源将在当前页面上使用时才应使用它。 Chromium 中的错误导致其行为使得通过`<link rel=preload>`发出的请求始终在预加载扫描器看到的其他请求之前启动，即使这些请求具有更高的优先级。诸如此类的问题阻碍了优化计划。

### HTTP2 Prioritization HTTP2 优先级

协议本身没有提供很多选项或旋钮来调整资源的顺序和优先级。即使可以提供更好的优先级原语， HTTP2 优先级也存在潜在问题，导致优化排序变得困难。主要是，我们无法预测服务器或 CDN 将以什么顺序优先考虑单个资源的请求。一些 CDN 会重新确定请求的优先级，而其他 CDN 则实施部分优先级、有缺陷的优先​​级或无优先级。

### Resource level optimization 资源水平优化

有效的排序需要以最佳方式提供正在排序的资源，以便它们能够快速加载。关键的 CSS 应该内联，图像的大小应该正确，JS 应该进行代码分割并增量交付。

该框架本身缺乏允许代码分割和增量服务 JS 和数据的结构。用户必须依赖以下之一来分割大块的 1P JS

- 现代反应（悬念/并发模式/数据获取）-这仍然仅可用于实验
    https://17.reactjs.org/docs/concurrent-mode-reference.html
- 使用动态导入进行延迟加载 - 这并不直观，开发人员需要手动识别分割代码的边界。

在代码分割时，由于粒度与性能的权衡，开发人员需要实现正确的块粒度。

更高的粒度是可取的，因为它
- 最大限度地减少单个路由和后续用户交互所需的 JS
- 允许缓存常见依赖项。这确保了库中的更改不需要重新获取整个包

同时，代码分割时粒度太大可能会很糟糕，因为太多的小块会降低单个块的压缩率并影响浏览器性能。

资源优化还需要消除死代码或未使用的代码。不必要的或过时的 JS 可能经常被发送到现代浏览器，这会对性能产生负面影响。对于现代浏览器来说，不需要将 JS 转译为 ES5 并与 polyfill 捆绑在一起。库和 npm 包通常不以 ES 模块格式发布。这使得捆绑商很难进行树摇动和优化

您可能已经注意到，这些问题并不限于一组特定的资源或平台。要解决这些问题，需要了解整个技术堆栈以及如何合并不同的资源以实现最佳指标。在我们定义整体优化策略之前，让我们看看个别资源需求如何违背我们的目的。

## 有关资源的更多信息 - 关系、约束和优先级

在上一节中，我们给出了一些示例，说明如何触发 FCP 或 LCP 等特定事件需要某些资源。在讨论使用它们的方法之前，让我们首先尝试理解所有这些依赖关系。以下是在定义理想序列之前需要考虑的建议、约束和陷阱的资源明智列表。

### Critical CSS 关键CSS

关键 CSS是指 FCP 所需的最低 CSS。最好将此类 CSS 内联到 HTML 中，而不是从另一个 CSS 文件导入。在任何给定时间只应下载路由所需的 CSS，并且应相应地拆分所有关键 CSS。

如果无法内联，则应预加载关键 CSS，并从与文档相同的源提供服务。避免从多个域提供关键 CSS 或直接使用第三方关键 CSS（例如 Google Fonts）。您自己的服务器可以充当第 3 方关键 CSS 的代理。

获取 CSS 的延迟或获取 CSS 的顺序不正确可能会影响 FCP 和 LCP。为了避免这种情况，非内联 CSS 应优先排序并排在网络上的 1P JS 和 ATF 图像之上。

过多的内联 CSS 可能会导致 HTML 膨胀以及主线程上的样式解析时间过长。这可能会伤害 FCP。因此，确定关键内容和代码分割至关重要。

内联 CSS 无法缓存。解决此问题的一种方法是对可缓存的 CSS 进行重复请求。但请注意，这可能会导致多个整页布局，从而影响 FID。

### Fonts 字体

与关键 CSS 一样，关键字体的 CSS 也应该内联。如果无法内联，则应使用指定的预连接来加载脚本。获取字体（例如，谷歌字体或来自不同域的字体）的延迟可能会影响 FCP。预连接告诉浏览器提前建立与这些资源的连接。

内联字体会使 HTML 显着膨胀并延迟启动其他关键资源获取。字体回退可用于解锁 FCP 并使文本可用。但是，使用字体回退可能会因跳跃字体而影响CLS 。由于当真实字体到达时，主线程上可能存在较大的样式和布局任务，因此它还会影响 FID。

### Above the Fold (ATF) Images 首屏 (ATF) 图像

这是指用户在页面加载时最初可见的图像，因为它们位于视口内。 ATF 图像的一个特例是页面的英雄图像。所有 ATF 图像都应调整大小。未调整大小的图像会损害 CLS 指标，因为完全渲染时会发生布局变化。 ATF 图像的占位符应由服务器呈现。

延迟的英雄图像或空白占位符将导致 LCP 延迟。此外，如果占位符大小与实际英雄图像的固有大小不匹配并且图像在替换时未覆盖，LCP 将重新触发。理想情况下，ATF 图像不应对 FCP 产生影响，但实际上，图像可能会引发 FCP。

### Below the Fold (BTF) Images 非首屏 (BTF) 图片

这些图像在页面加载时不会立即对用户可见。因此，它们是延迟加载的理想选择。这确保它们不会与页面上所需的 1P JS 或重要的 3P 发生冲突。如果 BTF 图像在 1P JS 或重要的 3P 资源之前加载，FID 就会延迟。

### 1P JavaScript

1P JS 影响应用程序的交互准备情况。它可能会在图像和 3P JS 后面的网络上以及 3P JS 后面的主线程上出现延迟。因此，它应该在网络上的 ATF 图像之前开始加载，并在主线程上的 3P JS 之前执行。 1P JS 不会阻止服务器端渲染的页面中的 FCP 和 LCP。

### 3P JavaScript

HTML 头中的 3P 同步脚本可能会阻止 CSS 和字体解析，从而阻止 FCP。 head 中的同步脚本也会阻止 HTML body 解析。主线程上的 3P 脚本执行可以延迟 1P 脚本执行并推出 Hydration 和 FID。因此，加载 3P 脚本需要更好的控制。

无论技术堆栈和浏览器如何，这些建议和限制通常都适用。请注意，建议也可能成为约束。例如，内联字体和 CSS 很棒，但太多会导致臃肿。诀窍是在“太少太晚”和“太多太早”之间找到平衡。

1. CSS 和字体以最高优先级加载。这应该可以帮助我们确定关键 CSS 和字体的优先级。
2. 根据脚本在文档中的位置以及它们是异步、延迟还是阻塞，脚本会获得不同的优先级。在第一个图像（或文档中较早的图像）之前请求的阻止脚本比在获取第一个图像之后请求的阻止脚本具有更高的优先级。异步/延迟/注入脚本，无论它们位于文档中的哪个位置，都具有最低优先级。因此，我们可以通过使用async 和 defer的适当属性来优先考虑不同的脚本。
3. 可见且位于视口中的图像的优先级（净值：中）高于不在视口中的图像（净值：最低）。这有助于我们优先考虑 ATF 图像而不是 BTF 图像。

## 理想的加载顺序是什么

有了这个背景，我们现在可以提出一个加载顺序，该顺序应该优化 1P 和 3P 资源的加载。建议的序列使用Next.js服务器端渲染 (SSR) 作为优化参考。

根据我们的经验，以下是我们在优化之前观察到的 Next.js SSR 应用程序的典型加载顺序。

CSS 在 JS 之前预加载，但未内联JavaScript

1P JS 已预加载

3P JS 不受管理，仍然可以在文档中的任何位置阻塞渲染。

Fonts 字体

字体既不是内联的，也不使用预连接

字体通过外部样式表加载，这会延迟加载

字体可能会或可能不会显示阻塞。

Images 图片

英雄图像没有优先顺序

Both ATF and BTF images are not optimized

ATF 和 BTF 图像均未优化

### 没有 3P 的建议序列

1. 我们建议尽可能避免预加载，因为它会强制对每个前面的资源进行手动预加载，并且还会导致手动管理排序。尤其应避免对字体进行预加载，因为检测关键字体很困难。
2. Font-CSS 最好是内联的。应使用预连接获取来自其他来源的字体。
3. 建议对来自其他来源的所有资源进行预连接。这将确保提前建立连接来下载这些资源。
4. 应在用户交互开始 (FID) 之前获取非关键 CSS。这将避免由于后续渲染此类 CSS 导致的样式问题。
5. 在网络上先获取第一方 JS，再获取 ATF 图片。下载和解析 JS 需要一些时间。
6. 在解析 1P JS 的同时，主线程上的 HTML 解析和 ATF 图像的下载可以并行继续。

为了实现所需的顺序，我们建议对 Next 使用 ScriptLoader 组件。该组件旨在“优化关键渲染路径并确保外部脚本不会成为最佳页面加载的瓶颈。”与我们的讨论最相关的功能是加载优先级。这使我们能够在不同的里程碑安排脚本以支持不同的用例。以下是可用的加载优先级值

After-Interactive: Loads the specific 3P script after the next hydration. This can be used to load Tag-managers, Ads, or Analytics scripts that we want to execute as early as possible but after 1P scripts.
After-Interactive ：下次水合后加载特定的3P脚本。这可用于加载我们希望在 1P 脚本之后尽早执行的标签管理器、广告或分析脚本。

Before-Interactive: Loads the specific 3P script before hydration. It can be used in cases where we want the 3P script to execute before the 1P script. Eg., polyfill.io, bot detection, security and authentication, user consent management (GDPR), etc.
Before-Interactive ：在水合之前加载特定的 3P 脚本。它可以用于我们希望 3P 脚本在 1P 脚本之前执行的情况。例如，polyfill.io、机器人检测、安全和身份验证、用户同意管理 (GDPR) 等。

Lazy-Onload: Prioritize all other resources over the specified 3P script and lazy load the script. It can be used for CRM components like Google Feedback or Social Network specific scripts like those used for share buttons, comments, etc.
Lazy-Onload ：将所有其他资源优先于指定的 3P 脚本并延迟加载脚本。它可用于 CRM 组件，例如 Google 反馈或社交网络特定脚本，例如用于共享按钮、评论等的脚本。

Thus, preconnect, script attributes and ScriptLoader for Next.js together can help us get the desired sequence for all our scripts.
因此，预连接、脚本属性和 Next.js 的 ScriptLoader 一起可以帮助我们获得所有脚本所需的序列。