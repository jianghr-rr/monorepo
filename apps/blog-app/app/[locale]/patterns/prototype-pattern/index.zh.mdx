import Image from 'next/image';

# 原型链模式

在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象
- 使用类的方式来描述对象
- 利用原型来描述对象

如何复用对象的操作
- 不去真的复制一个原型对象，而是使得新对象持有一个原型的引用
- 复制对象，从此两个对象再无关联

原型系统的概括
- 如果对象有字段[[prototype]]，就是对象的原型
- 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止

和对象相关的两个私有属性
- 函数对象的定义是：具有[[call]]私有字段的对象
- 构造器对象的定义是：具有私有字段[[construct]]的对象。

### 在看原型链之前需要知道的知识点

#### __proto__ vs [[Prototype]]

在 JavaScript 中，__proto__ 是浏览器提供的一个访问器属性，它允许我们访问或修改对象的 [[Prototype]]（即原型）。但它不是 [[Prototype]] 本身，而是对 Object.prototype 上 getPrototypeOf 和 setPrototypeOf 方法的一个封装。

__proto__ 的本质

浏览器（以及 Node.js）提供的 __proto__ 其实是 Object.prototype 上的一个getter 和 setter，它的底层实现相当于：

``` JavaScript
Object.defineProperty(Object.prototype, '__proto__', {
  get() {
    return Object.getPrototypeOf(this);
  },
  set(proto) {
    Object.setPrototypeOf(this, proto);
  }
});
```

浏览器实现的 __proto__ 其实是 Object.prototype 上的访问器属性

| 名称          | 类型        | 作用                  | 是否标准                                | 兼容性               |
|--------------|------------|-----------------------|---------------------------------|-------------------|
| `[[Prototype]]` | 内部字段   | 记录对象的原型        | 规范定义（ECMA-262），不可直接访问 | 所有 JavaScript 引擎 |
| `__proto__`   | 访问器属性 | 访问或修改 `[[Prototype]]` | 非标准，但已被 ES6 纳入 Annex B（仅限浏览器） | 现代浏览器、Node.js  |

### prototype vs [[Prototype]]

prototype 是什么？
- 只有函数对象才有 prototype 属性
- prototype 指向一个 对象，这个对象将作为 实例对象的原型
- 实例对象的 [[Prototype]]（即 __proto__）会指向这个 prototype

### constructor vs [[Construct]]

虽然 XXXX.prototype 本身没有 [[Construct]]，但它默认有一个 constructor 属性，指向创建它的构造函数

``` JavaScript
function Person() {}
console.log(Person.prototype.constructor === Person); // true
```

constructor 属性是原型链上的普通属性，不是内部字段 [[Construct]]。

属性/内部字段	作用	适用于	是否可直接访问
[[Construct]]	允许对象使用 new 调用	只有构造函数（function、class）有	❌ 不可直接访问
constructor	指向构造函数	prototype 对象通常有	✅ 可直接访问

一下参考：https://www.patterns.dev/vanilla/prototype-pattern

原型模式是在同一类型的许多对象之间共享属性的有用方法

## 通过 Person 构造函数分析原型链
``` JavaScript
function Person(name) {
  this.name = name;
}

const person = new Person("Alice");
```
<Image
    src={'/images/patterns/prototype/1.png'}
    width={1024}
    height={720}
    alt="prototype-1"
/>

``` JavaScript
console.log(Person.prototype);       // { constructor: Person }
console.log(person.__proto__);       // { constructor: Person }
console.log(person.__proto__ === Person.prototype); // true
```

### 构造函数 __proto__ 指向 Function.prototype & 构造函数 prototype 的 __proto__ 指向 Object.prototype

``` JavaScript
console.log(Person.__proto__ === Function.prototype); // true
```
- Person 本身是一个函数，而所有函数的 [[Prototype]]（即 __proto__）都指向 Function.prototype。
- 这说明 Person 是 Function 的一个实例。

构造函数 prototype 的 __proto__ 指向 Object.prototype

``` JavaScript
console.log(Person.prototype.__proto__ === Object.prototype); // true
```

- Person.prototype 也是一个对象，所有对象的 [[Prototype]] 默认都指向 Object.prototype，所以 Person.prototype.__proto__ === Object.prototype。

<Image
    src={'/images/patterns/prototype/2.png'}
    width={1024}
    height={720}
    alt="prototype-2"
/>

 JavaScript 里的函数（包括 Function 和 Object）本质上都是 Function 的实例

### 深入分析 Function 和 Object

<Image
    src={'/images/patterns/prototype/2.png'}
    width={1024}
    height={720}
    alt="prototype-3"
/>

#### 为什么 Function.__proto__ === Function.prototype？

``` JavaScript
console.log(Function.__proto__ === Function.prototype); // true
```

- Function 本身是一个函数，而所有函数的 [[Prototype]]（即 __proto__）都指向 Function.prototype。
- 这说明 Function 是 Function 的一个实例。

#### 为什么 Object.__proto__ === Function.prototype？

``` JavaScript
console.log(Object.__proto__ === Function.prototype); // true
```

- Object 本身是一个函数，而所有函数的 [[Prototype]]（即 __proto__）都指向 Function.prototype。
- 这说明 Object 是 Function 的一个实例。

``` JavaScript
console.log(Function.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

- Function.prototype 是一个对象，所有对象的 [[Prototype]] 默认都指向 Object.prototype。
- Object.prototype 也是一个对象，所有对象的 [[Prototype]] 默认都指向 null。
